#!/usr/bin/env python

"""
======== Steps for finding optimal cuts ================

Do the following steps when first running the file:

a) Set `GET_YIELDS` to 1. This will apply the initial cuts and save all relevant background 
   and signal numbers into log files. (note: GET_YIELDS & MAKE_SOB are function arguments for
   the "main()" function in this file [line 134]. When we set these arguments to either 1 or 0, 
   we are telling python to run the functions [lines 200 & 207] or not, respectively. -DE)

b) Set `MAKE_SOB` to 0. It is necessary to create the relevant log files to be able to make
   the plots.

c) Ensure that `RUN_SUBSET = True`. This will replace the extensive signal name list with a much
   shorter version, for the purpose of debugging.

d) Run the `./run_MakeVarDist_and_SB.py --batch BATCH` command to make the log files.

e) Reset `GET_YIELDS` and `MAKE_SOB` in main to 0 and 1, respectively. This will generate the plots
   based on the recently created log files.
"""

import os
import pwd
from Load_SOB import * #imports all names and packages from Load_SOB -DE

debug = 0
RUN_SUBSET = True   # set True to only run on a very small portion of cut space

# STEP 1 -  apply cuts and save final yields for all background and signal samples
GET_YIELDS = 0
# STEP 2  get numbers from above saved log files, make tables and calculate significance. Finally make SOB plots for
# every signal sample
MAKE_SOB = 0
# STEP 3 get the cut strings from tables saved in the above step and plot variables corresponding to those cuts
DRAW_VARS = 1

# outputDir = '/data2/users/jabeen/DATA_2/SB-All'
# resultsdir = '/data2/users/jabeen/DATA_2/SB-All'

# Set output dir to SB-All in one's working dir on /data2 or /data
# The SB-All dir will be autogenerated later
uname = pwd.getpwuid(os.getuid())[0]  # get username
outputDir = 'data'  # defaults to saving stuff to ./data
resultsdir = 'data'
if os.path.isdir('/data2/users/' + uname + '/'):
    outputDir = '/data2/users/' + uname + '/SB-All'
    resultsdir = '/data2/users/' + uname + '/SB-All'
elif os.path.isdir('/data/users/' + uname + '/'):
    outputDir = '/data/users/' + uname + '/SB-All'
    resultsdir = '/data/users/' + uname + '/SB-All'

parser = ArgumentParser() #parsers for command-line options
parser.add_argument('--baseDirMuG', default=None, dest='baseDirMuG', required=False, help='Path to muon base directory')
# stitparser.add_argument('--baseDirElG', default=None, dest='baseDirElG', required=False,
# help='Path to electron base directory')
parser.add_argument('--baseDirElG', default=None, dest='baseDirElG', required=False,
                    help='Path to electron base directory')
parser.add_argument('--outputDir', default=None, dest='outputDir', required=False,
                    help='Output directory to write histograms')
parser.add_argument('--data', default=False, dest='data', required=False, help='Use data or MC')
parser.add_argument('--batch', default=None, dest='batch', required=False, help='Supress X11 output') #we use this argument frequently-
#-to 'supress 11 output' -DE
options = parser.parse_args()

_TREENAME = 'UMDNTuple/EventTree'
_FILENAME = 'tree.root'
_LUMI = 36000

# File that loads the (real, LHC data) cross sections
#_XSFILE = 'WG_Analysis/Plotting/cross_sections/photon17.py'
_XSFILE   = 'cross_sections/photon17.py'

# File that loads the simulation data
#_SAMPCONF = 'WG_Analysis/Plotting/Modules/Resonance2017.py'
# _BASEPATH = '/home/jkunkle/usercode/Plotting/LimitSetting/'
_SAMPCONF = 'Modules/Resonance2017.py'
# _SAMPCONF = 'Modules/Resonance.py'

if options.batch: #dest of --batch option after parsed -DE
    ROOT.gROOT.SetBatch(True)
if options.outputDir is not None:
    if not os.path.isdir(options.outputDir):
        os.makedirs(options.outputDir)

ROOT.gStyle.SetOptStat(0)
ROOT.gStyle.SetOptFit(1)

# ROOT.gROOT.SetBatch(True)

# if no options given for --baseDirMug & --baseDirElg [not parsed in line 56 or 59], here are the default directories to read -DE 
# if options.baseDirMuG is None: options.baseDirMuG = "/data2/users/kakw/Resonances2017/LepGamma_mug_2019_09_15/"
if options.baseDirMuG is None: options.baseDirMuG = "/data2/users/kakw/Resonances2017/LepGamma_mug_2019_10_28/"
# if options.baseDirElG is None: options.baseDirElG = "/data2/users/kakw/Resonances2017/LepGamma_elg_2019_09_15/"
if options.baseDirElG is None: options.baseDirElG = "/data2/users/kakw/Resonances2017/LepGamma_elg_2019_10_28/"
# options.baseDirElG = "/data/users/friccita/WGammaNtuple/LepGamma_elg_2019_04_11/"
# =========Provide the string for base cuts to compare the sigbificanse against in the final SOB plots
# sigstr_BCuts = ["selbase_el_gtmet25_phpt80_elpt40_elidTight_phidTight_invZ10",
# "selbase_el_gtmet25_phpt80_elpt40_elidTight_phidTight_invZ10",
# "selbase_el_gtmet25_phpt80_elpt40_elidTight_phidTight_invZ10"]
sigstr_BCuts = "selbase_el_gtmet25_phpt80_elpt40_elidTight_phidTight_invZ10"

signal_name = ["MadGraphResonanceMass200_width0p01"
    , "MadGraphResonanceMass250_width5"
    , "MadGraphResonanceMass300_width5"
    , "MadGraphResonanceMass400_width5"
    , "MadGraphResonanceMass450_width5"
    , "MadGraphResonanceMass500_width5"
    , "MadGraphResonanceMass700_width0p01"
    , "MadGraphResonanceMass800_width0p01"
    , "MadGraphResonanceMass800_width5"
    , "MadGraphResonanceMass900_width0p01"
    , "MadGraphResonanceMass900_width5"
    , "MadGraphResonanceMass1000_width0p01"
    , "MadGraphResonanceMass1200_width0p01"
    , "MadGraphResonanceMass1400_width0p01"
    , "MadGraphResonanceMass1400_width5"
    , "MadGraphResonanceMass1800_width5"
    , "MadGraphResonanceMass2000_width0p01"
    , "MadGraphResonanceMass2000_width5"
    , "MadGraphResonanceMass2200_width0p01"
    , "MadGraphResonanceMass2200_width5"
    , "MadGraphResonanceMass2600_width0p01"
    , "MadGraphResonanceMass2800_width0p01"
    , "MadGraphResonanceMass3500_width5"
    , "MadGraphResonanceMass4000_width5"]

# sigstr = ["MadGraphResonanceMass250_width5",
# "MadGraphResonanceMass1000_width0p01",
# "MadGraphResonanceMass2200_width0p01"]

def main():
    """
    Grab data, apply baseline cuts, and then run the following 3 steps of analysis:
        1. Sample from each combination of cuts, saving logs and histograms of the sampled values
        2. Filter cuts by a significance threshold, and save and plot signal and background for each "significant" cut
        3. Plot the real data for the cuts decided in Step 2
    """
    if options.outputDir:
        f1 = ROOT.TFile("%s/output.root" % (options.outputDir), "RECREATE")

    # sampManMuG= SampleManager( options.baseDirMuG, _TREENAME, filename=_FILENAME, xsFile=_XSFILE, lumi=_LUMI )
    sampManElG = SampleManager(options.baseDirElG, _TREENAME, filename=_FILENAME, xsFile=_XSFILE, lumi=_LUMI)

    # sampManMuG.ReadSamples( _SAMPCONF )
    sampManElG.ReadSamples(_SAMPCONF)

    # Set values for cuts.
    cut_phpt = [(phpt70, "phpt70"), (phpt80, "phpt80"), (phpt90, "phpt90"), (phpt100, "phpt100"), (phpt105, "phpt105"),
                (phpt110, "phpt110"), (phpt120, "phpt120"), (phpt130, "phpt130"), (phpt140, "phpt140"),
                (phpt150, "phpt150"), (phpt160, "phpt160"), (phpt170, "phpt170"), (phpt180, "phpt180"),
                (phpt190, "phpt190"), (phpt200, "phpt200"), (phpt210, "phpt210"), (phpt220, "phpt220"),
                (phpt230, "phpt230"), (phpt240, "phpt240"), (phpt250, "phpt250")]

    cut_elid = [(elidTight, "elidTight"), (elidMedium, "elidMedium"), (elidLoose, "elidLoose")]
    cut_phid = [(phidTight, "phidTight"), (phidMedium, "phidMedium"), (phidLoose, "phidLoose")]
    cut_z = [(invZ10, "invZ10"), (invZ15, "invZ15"), (invZ20, "invZ20")]

    cut_met = [(gtmet25, "gtmet25"), (gtmet30, "gtmet30"), (gtmet40, "gtmet40"), (gtmet50, "gtmet50"),
               (gtmet60, "gtmet60"), (gtmet70, "gtmet70"), (gtmet80, "gtmet80"), (gtmet90, "gtmet90"),
               (gtmet100, "gtmet100"), (gtmet110, "gtmet110"), (gtmet120, "gtmet120"), (gtmet130, "gtmet130"),
               (gtmet140, "gtmet140"), (gtmet150, "gtmet150"), (gtmet160, "gtmet160"), (gtmet170, "gtmet170"),
               (gtmet180, "gtmet180"), (gtmet190, "gtmet190"), (gtmet200, "gtmet200"), (gtmet210, "gtmet210")]

    cut_elpt = [(elpt30, "elpt30"), (elpt40, "elpt40"), (elpt50, "elpt50"), (elpt60, "elpt60"), (elpt70, "elpt70"),
                (elpt80, "elpt80"), (elpt90, "elpt90"), (elpt100, "elpt100"), (elpt110, "elpt110"),
                (elpt120, "elpt120"), (elpt130, "elpt130"), (elpt140, "elpt140"), (elpt150, "elpt150"),
                (elpt160, "elpt160")]

    # el_pt0_selbase_el_gtmet30_phpt60_elpt160_elidLoose_phidLoose_invZ20_.pdf.log

    # Uncomment these instead for debugging selbase_el_gtmet25_phpt80_elpt40_elidTight_phidTight_invZ10
    # Reset signal names for debugging purposes. ach
    if RUN_SUBSET:
        signal_name = ["MadGraphResonanceMass500_width5", "MadGraphResonanceMass1000_width0p01"]
        cut_met = [(gtmet30,"gtmet30")]
        cut_elpt = [(elpt160,"elpt160")]
        cut_phpt = [(phpt60,"phpt60")]
        cut_elid = [(elidLoose,"elidLoose")]
        cut_phid = [(phidLoose,"phidLoose")]
        cut_z = [ (invZ20, "invZ20")]

    selarray = [[(selbase_el, "selbase_el"), ], cut_met, cut_phpt, cut_elpt, cut_elid, cut_phid, cut_z]
    # variables to be plotted
    vararray = [  # ("el_n",        (10,0,10),      "num of electrons"), ## variable name, x axis range, x axis label
        ("el_pt[0]", (50, 0, 500), "p_{T}(e, leading)"),
        ("el_eta[0]", (10, -5.0, 5.0), "#eta (e, leading)"),
        # ("ph_n",        (10,0,10),      "num of photons"),
        ("ph_pt[0]", (50, 0, 500), "p_{T}(#gamma, leading)"),
        ("ph_eta[0]", (10, -5.0, 5.0), "#eta (#gamma, leading)"),
        ("met_pt", (50, 0, 500), "MET"),
        ("met_phi", (20, -pi, pi), "MET #phi")
    ]

    #    legend_config = {'legendLoc':"Double","legendTranslateX":0.3}
    hist_config = {"logy": 1, "blind": True, "weight": "PUWeight*NLOWeight"}

    if GET_YIELDS:
        vararray = [("el_pt[0]", (50, 0, 200), "p_{T}(e, leading)")]
        makeplots(0, sampManElG, vararray, resultsdir, selarray, hist_config, {}, "")
        # legend_config = {'legendLoc':"Double","legendTranslateX":0.3}
        # hist_config = {"blind":True, "weight": "PUWeight*NLOWeight"}
        # makeplots(vararray, selarray, hist_config, legend_config)

    if MAKE_SOB:
        vararray = [("el_pt[0]", (50, 0, 200), "p_{T}(e, leading)")]
        for j in range(len(signal_name)):  # plot SOB for each signal of interest
            makesob_plots(1, sigstr_BCuts, sampManElG, resultsdir, vararray, signal_name[j], selarray, hist_config, {},
                          "")

    n = 0
    if DRAW_VARS:
        for j in range(len(signal_name)):
            if n == 0:
                legend_config = {'legendLoc': "Double", "legendTranslateX": 0.3}
            else:
                legend_config = {'legendLoc': "Double", "legendTranslateX": 0.95}
            n = n + 1
            hist_config = {"logy": 1, "blind": True, "weight": "PUWeight*NLOWeight"}

            make_selected_plots(sigstr_BCuts, sampManElG, resultsdir, vararray, signal_name[j], selarray, hist_config,
                                {}, "log")

            hist_config = {"blind": True, "weight": "PUWeight*NLOWeight"}

            make_selected_plots(sigstr_BCuts, sampManElG, resultsdir, vararray, signal_name[j], selarray, hist_config,
                                {}, "")

    if options.outputDir:
        # write and close root file
        f1.Write()
        f1.Close()


main()
